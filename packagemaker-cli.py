#!/usr/bin/env python3
# packagemaker_tui_complete.py
# Versión TUI completa del packagemaker-cli adaptada para terminal
# Incluye: creación de proyecto, generación de LICENSE/details.xml, empaquetado (.iflapp),
# instalación/desinstalación, ejecución de scripts del proyecto y utilidades varias.
# Guarda este archivo junto al packagemaker-cli.py si deseas compararlos.
# Requiere Python 3.7+; en Windows instala colorama (pip install colorama).

import os
import sys
import time
import hashlib
import shutil
import zipfile
import urllib.request
import urllib.error
import subprocess
import xml.etree.ElementTree as ET

# --- Configuración ---
if sys.platform.startswith("win"):
    BASE_DIR = os.path.join(os.environ.get("USERPROFILE", ""), "Documents", "Packagemaker Projects")
    FLATR_APPS = os.path.join(os.environ.get("USERPROFILE", ""), "Documents", "Flatr Apps")
    LINKED_SYS = "knosthalij"
else:
    BASE_DIR = os.path.expanduser("~/Documents/Packagemaker Projects")
    FLATR_APPS = os.path.expanduser("~/Documents/Flatr Apps")
    LINKED_SYS = "danenone"

DEFAULT_FOLDERS = ["app","assets","config","docs","source","lib"]
os.makedirs(BASE_DIR, exist_ok=True)
os.makedirs(FLATR_APPS, exist_ok=True)

# ANSI colors (basic)
RESET = "\033[0m"
BOLD = "\033[1m"
FG_GREEN = "\033[38;5;34m"
FG_RED = "\033[38;5;196m"
FG_ORANGE = "\033[38;5;208m"
FG_BLUE = "\033[38;5;33m"
FG_GRAY = "\033[38;5;244m"

try:
    if os.name == "nt":
        import colorama
        colorama.init()
except Exception:
    pass

# --- Utilities ---
def getversion():
    return time.strftime("%y.%m-%H.%M")

def verify_github_username(username, timeout=8):
    if not username or not username.strip():
        return False, "El username no puede estar vacío"
    username = username.strip()
    url = f"https://api.github.com/users/{username}"
    try:
        req = urllib.request.Request(url)
        req.add_header('User-Agent', 'Packagemaker-TUI/1.0')
        with urllib.request.urlopen(req, timeout=timeout) as response:
            if response.status == 200:
                return True, "Username válido"
            return False, f"Respuesta inesperada: {response.status}"
    except urllib.error.HTTPError as e:
        if e.code == 404:
            return False, "El username no existe en GitHub"
        return False, f"Error HTTP: {e.code}"
    except Exception as e:
        return False, f"Error de conexión: {e}"

def safe_input(prompt=""):
    try:
        return input(prompt)
    except (KeyboardInterrupt, EOFError):
        print()
        return ""

# --- File generators (LICENSE, details.xml, store key) ---
def generate_license(path, author_name=None):
    lic_path = os.path.join(path, "LICENSE")
    year = time.strftime("%Y")
    author = author_name or "Unknown"
    gpl_text = f"""GNU GENERAL PUBLIC LICENSE
Version 3, 29 June 2007

Copyright (C) {year} {author}

... (shortened boilerplate) ...

This file is a placeholder GPLv3 license generated by packagemaker_tui.
Refer to https://www.gnu.org/licenses/gpl-3.0.txt for the full license text.
"""
    with open(lic_path, "w", encoding="utf-8") as f:
        f.write(gpl_text)
    return lic_path

def create_details_xml(path, publisher, internal_name, display_name, version, author, platform_tag):
    root = ET.Element("app")
    ET.SubElement(root, "publisher").text = publisher.capitalize()
    ET.SubElement(root, "app").text = internal_name
    ET.SubElement(root, "name").text = display_name
    ET.SubElement(root, "version").text = f"v{version}"
    ET.SubElement(root, "with").text = sys.platform
    ET.SubElement(root, platform_tag).text = getversion()
    corr = hashlib.sha256(f"{publisher}.{internal_name}.v{version}".encode()).hexdigest()
    ET.SubElement(root, "correlationid").text = corr
    ET.SubElement(root, "rate").text = "EVERYONE"
    ET.SubElement(root, "author").text = author
    details_path = os.path.join(path, "details.xml")
    tree = ET.ElementTree(root)
    tree.write(details_path, encoding="utf-8", xml_declaration=True)
    return details_path

def write_storekey(path, fn):
    hv = hashlib.sha256(fn.encode()).hexdigest()
    sk = os.path.join(path, ".storedetail")
    with open(sk, "w", encoding="utf-8") as f:
        f.write(f"#store key protection id:\n{hv}\\n")
    return sk

# --- Core actions ---
def create_project_interactive():
    print(FG_ORANGE + BOLD + "\n== Crear nuevo proyecto ==" + RESET)
    publisher = safe_input("Fabricante (ej: influent) [influent]: ").strip() or "influent"
    internal = safe_input("Nombre interno (ej: mycoolapp) [mycoolapp]: ").strip() or "mycoolapp"
    display = safe_input(f"Título (ej: MyCoolApp) [{internal}]: ").strip() or internal
    version = safe_input("Versión (ej: 1.0) [auto]: ").strip()
    author = safe_input("Autor (username GitHub) [obligatorio]: ").strip()
    if not author:
        print(FG_RED + "Autor obligatorio. Abortando." + RESET); return
    ok, msg = verify_github_username(author)
    if not ok:
        print(FG_RED + f"Verificación GitHub fallida: {msg}" + RESET); return
    if not version:
        version = f"1-{getversion()}-{LINKED_SYS}"
    else:
        version = f"{version}-{getversion()}-{LINKED_SYS}"
    folder_name = f"{publisher}.{internal}.v{version}"
    full_path = os.path.join(BASE_DIR, folder_name)
    try:
        os.makedirs(full_path, exist_ok=True)
        for d in DEFAULT_FOLDERS:
            os.makedirs(os.path.join(full_path, d), exist_ok=True)
        # create basic files
        main_py = os.path.join(full_path, f"{internal}.py")
        with open(main_py, "w", encoding="utf-8") as f:
            f.write(f"""#!/usr/bin/env python3
# {display}
# publisher: {publisher}
# name: {internal}
# version: {version}

if __name__ == '__main__':
    print('Hello from {display}!')
""")
        # autorun scripts
        with open(os.path.join(full_path, "autorun.bat"), "w", encoding="utf-8") as f:
            f.write(f"@echo off\\npython {internal}.py\\n")
        with open(os.path.join(full_path, "autorun"), "w", encoding="utf-8") as f:
            f.write(f"""#!/usr/bin/env sh
python3 "{internal}.py"
""")
        # requirements
        with open(os.path.join(full_path, "lib", "requirements.txt"), "w", encoding="utf-8") as f:
            f.write("# requirements\\n")
        # license, details, storekey
        generate_license(full_path, author_name=author)
        create_details_xml(full_path, publisher, internal, display, version, author, LINKED_SYS)
        write_storekey(full_path, f"{publisher}.{internal}.v{version}")
        print(FG_GREEN + f"Proyecto creado: {full_path}" + RESET)
    except Exception as e:
        print(FG_RED + f"Error creando proyecto: {e!r}" + RESET)

def build_package_interactive():
    print(FG_ORANGE + BOLD + "\\n== Construir paquete (.iflapp) ==" + RESET)
    publisher = safe_input("Fabricante (ej: influent) [influent]: ").strip() or "influent"
    internal = safe_input("Nombre interno (ej: mycoolapp) [mycoolapp]: ").strip() or "mycoolapp"
    version = safe_input("Versión (ej: 1.0) [auto]: ").strip()
    if not version:
        version = f"1-{getversion()}"
    folder = f"{publisher}.{internal}.v{version}"
    path = os.path.join(BASE_DIR, folder)
    if not os.path.isdir(path):
        print(FG_RED + "Carpeta no encontrada: " + path + RESET)
        return
    out = os.path.join(BASE_DIR, folder + ".iflapp")
    tmpzip = out + ".zip"
    try:
        with zipfile.ZipFile(tmpzip, 'w', zipfile.ZIP_DEFLATED) as zf:
            for root, _, files in os.walk(path):
                for f in files:
                    full = os.path.join(root, f)
                    arc = os.path.relpath(full, path)
                    zf.write(full, arc)
                    print(FG_BLUE + f"añadiendo: {arc}" + RESET)
        if os.path.exists(out):
            os.remove(out)
        os.rename(tmpzip, out)
        print(FG_GREEN + f"Paquete creado: {out}" + RESET)
    except Exception as e:
        print(FG_RED + f"Error construyendo paquete: {e}" + RESET)

def list_local_projects():
    print(FG_ORANGE + BOLD + "\n== Proyectos locales ==" + RESET)
    if not os.path.isdir(BASE_DIR):
        print(FG_GRAY + "No se encontró directorio de proyectos." + RESET)
        return
    found = []
    for d in sorted(os.listdir(BASE_DIR)):
        p = os.path.join(BASE_DIR, d)
        if os.path.isdir(p):
            details = os.path.join(p, "details.xml")
            title = d
            version = "?"
            if os.path.exists(details):
                try:
                    tree = ET.parse(details); root = tree.getroot()
                    title = root.findtext("name") or d
                    version = root.findtext("version") or version
                except Exception:
                    pass
            print(FG_GREEN + f"- {title} | {version} -> {p}" + RESET)
            found.append((d, p))
    if not found:
        print(FG_GRAY + "No hay proyectos." + RESET)

def install_package_from_path():
    print(FG_ORANGE + BOLD + "\n== Instalar paquete desde ruta ==" + RESET)
    ruta = safe_input("Ruta al .iflapp/.zip: ").strip()
    if not ruta or not os.path.exists(ruta):
        print(FG_RED + "Ruta inválida." + RESET)
        return
    try:
        dest = os.path.join(FLATR_APPS, os.path.splitext(os.path.basename(ruta))[0])
        os.makedirs(dest, exist_ok=True)
        with zipfile.ZipFile(ruta, 'r') as zf:
            zf.extractall(dest)
        print(FG_GREEN + f"Instalado en: {dest}" + RESET)
    except Exception as e:
        print(FG_RED + f"Error instalando paquete: {e}" + RESET)

def uninstall_installed_app():
    print(FG_ORANGE + BOLD + "\n== Desinstalar app instalada ==" + RESET)
    try:
        apps = [d for d in sorted(os.listdir(FLATR_APPS)) if os.path.isdir(os.path.join(FLATR_APPS, d))]
        if not apps:
            print(FG_GRAY + "No hay apps instaladas." + RESET)
            return
        for i, a in enumerate(apps, 1):
            print(f"{i}) {a}")
        sel = safe_input("Número a desinstalar (o Enter para cancelar): ").strip()
        if not sel: return
        idx = int(sel)-1
        if 0 <= idx < len(apps):
            to_remove = os.path.join(FLATR_APPS, apps[idx])
            shutil.rmtree(to_remove)
            print(FG_GREEN + "App desinstalada." + RESET)
        else:
            print(FG_RED + "Selección inválida." + RESET)
    except Exception as e:
        print(FG_RED + f"Error: {e}" + RESET)

def run_script_from_project():
    print(FG_ORANGE + BOLD + "\n== Ejecutar script de un proyecto ==" + RESET)
    list_local_projects()
    proj = safe_input("Nombre de carpeta del proyecto (ej: influent.myapp.v1-...): ").strip()
    ppath = os.path.join(BASE_DIR, proj)
    if not os.path.isdir(ppath):
        if not os.path.isdir(ppath):
            print(FG_RED + "Proyecto no encontrado." + RESET)
            return
        pyfiles = []
        for root, _, files in os.walk(ppath):
            for f in files:
                if f.endswith('.py'):
                    pyfiles.append(os.path.join(root, f))
        if not pyfiles:
            print(FG_GRAY + "No hay scripts .py en el proyecto." + RESET)
            return
        for i, f in enumerate(pyfiles, 1):
            print(f"{i}) {os.path.relpath(f, ppath)}")
        sel = safe_input("Selecciona número (Enter cancelar): ").strip()
    if not sel: return
    idx = int(sel)-1
    if 0 <= idx < len(pyfiles):
        script = pyfiles[idx]
        print(FG_BLUE + f"Ejecutando {script}..." + RESET)
        try:
            subprocess.Popen([sys.executable, script], cwd=os.path.dirname(script))
            print(FG_GREEN + "Proceso iniciado." + RESET)
        except Exception as e:
            print(FG_RED + f"Error al ejecutar: {e}" + RESET)

# --- Small helpers ---
def show_header():
    os.system('cls' if os.name == 'nt' else 'clear')
    print(FG_ORANGE + BOLD + "Influent Package Maker — TUI".center(80) + RESET)
    print(FG_GRAY + f"Projects: {BASE_DIR}    Apps: {FLATR_APPS}".center(80) + RESET)
    print("-"*80)

def main_menu():
    actions = {
        "1": ("Crear proyecto", create_project_interactive),
        "2": ("Construir paquete .iflapp", build_package_interactive),
        "3": ("Listar proyectos locales", list_local_projects),
        "4": ("Instalar paquete desde ruta", install_package_from_path),
        "5": ("Desinstalar app instalada", uninstall_installed_app),
        "6": ("Ejecutar script desde proyecto", run_script_from_project),
        "q": ("Salir", None)
    }
    while True:
        show_header()
        for k,(label,_) in actions.items():
            if k == "q":
                print(f"{k}) {label}")
            else:
                print(f"{k}) {label}")
        sel = safe_input("\nSelecciona opción: ").strip().lower()
        if not sel: continue
        if sel == 'q':
            print(FG_GRAY + "Saliendo..." + RESET); break
        action = actions.get(sel)
        if action:
            try:
                action[1]()
            except Exception as e:
                print(FG_RED + f"Error: {e}" + RESET)
        else:
            print(FG_RED + "Opción inválida." + RESET)
        safe_input("\nPresiona Enter para continuar...")

if __name__ == '__main__':
    main_menu()
